package com.algorithm.study.dynamic_programming;

/**
 * 62. 不同路径
 * 二维数组：(1,1)=>(m,n)转化为(0,0)=>(m-1,n-1)
 * dp空间复杂度优化 O(m*n) => O(n)
 * 此前二维数组的方法，虽然是上方加左方，但是由于第一列或者第一行的值都是固定的，所以可以用一维数组替代，下标0的位置即为固定值，此题为1。
 * 二维数组的dp[0][1]和dp[1][0]两个数值，若是加上第一行的dp[0][j]能确定第二行的所有值，若是加上第一列的dp[i][0]能确定第二列的所有值。
 * 所以dp数组应该初始化为 dp[j] = 1。
 *
 * 两种遍历方式对应两种思路：
 * 列数组dp：
 *      1、确定dp数组元素及其下标的含义
 *         dp[i]代表同一列(0,j)到(i,j)，有dp[i]条不同的路径。
 *      2、确定动态规划转移方程
 *         dp[i] = dp[i] + dp[i-1]
 *      3、确定dp数组如何初始化
 *         因为(0,0)到(i,0)位置都只有直走一条路径，所以dp[i] = 1代表[1,m-1]范围的i值都为1。
 *         但是dp[0] = 1却是代表[1,n-1]范围的j值都为1
 *      4、确定遍历顺序
 *         先从上往下，再从右往左
 *      5、举例推导dp数组
 *         m = 3、n = 7
 *         1  1  1  1  1  1  1
 *         1  2  3  4  5  6  7
 *         1  3  6 10 15 21 28
 * 行数组dp：
 *      1、确定dp数组元素及其下标的含义
 *         dp[j]代表同一行(i,0)到(i,j)，有dp[j]条不同的路径。
 *      2、确定动态规划转移方程
 *         dp[j] = dp[j] + dp[j-1]
 *      3、确定dp数组如何初始化
 *         因为(0,0)到(0,j)位置都只有直走一条路径，所以dp[j] = 1代表[1,n-1]范围的j值都为1。
 *         但是dp[0] = 1却是代表[1,m-1]范围的i值都为1
 *
 *      4、确定遍历顺序
 *         先从右往左，再从上往下
 *      5、举例推导dp数组
 *         m = 3、n = 7
 *         1  1  1  1  1  1  1
 *         1  2  3  4  5  6  7
 *         1  3  6 10 15 21 28
 *
 * dp：时间复杂度(m*n)，具体是(m-1)*(n-1)、空间复杂度O(n)
 */
public class _4_UniquePaths_3 {

    public int uniquePaths1(int m, int n) {
        //一列的长度
        int[] dp = new int[m];
        for (int i = 0; i < m; i++) dp[i] = 1;
        for (int j = 1; j < n; j++) {
            for (int i = 1; i < m; i++) {
                dp[i] = dp[i] + dp[i - 1];
            }
        }
        return dp[m - 1];
    }

    public int uniquePaths2(int m, int n) {
        //一行的长度
        int[] dp = new int[n];
        for (int j = 0; j < n; j++) dp[j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        return dp[n - 1];
    }
}
